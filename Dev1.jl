# In this code DC Optimum Power Flow is implemented.
include("Clear_fnc.jl")
clearconsole()


using JuMP
using GLPK  # Linear programming solver, can replace with other solvers like Gurobi, CPLEX
using Statistics

# Define sets
G = [1,4]  # Set of generators
B = 1:6  # Set of buses
L = [(1, 2), #=(2, 3),=# (2,5), (3, 4), (3, 6)]  # Set of transmission lines
# Power base unit is kW
# Parameters
c_g = Dict(1 => 20.0, 4 => 5.0)  # Cost of generation for each generator
P_g_min = Dict(1 => 8, 4 => 8)  # Minimum generation limits
P_g_max = Dict(1 => 120.0, 4 => 120.0)  # Maximum generation limits

P_d = Dict(1 => 0.0, 2 => 40.0, 3 => 20.0, 4 => 0.0, 5 => 30.0, 6 => 30.0)  # Power demand at each bus
Line_bias = mean([P_d[b] for b in B])
# Line parameters
b_ij = Dict((1, 2) => 0.1, #=(2, 3) => 0.15,=# (2,5) => 0.1, (3, 4) => 0.1, (3, 6) => 0.1)  # Susceptance of each line
P_ij_min = Dict((1, 2) => -80.0, #=(2, 3) => -45.0,=# (2,5) => -40, (3, 4) => -60.0, (3, 6) => -40)  # Min power flow limits
P_ij_max = Dict((1, 2) => 80.0, #=(2, 3) => 45.0,=# (2,5) => 40, (3, 4) => 60.0, (3, 6) => 40)  # Max power flow limits

# Create the optimization model
model = Model(GLPK.Optimizer)

# Decision variables
@variable(model, P_g[g in G] >= 0)  # Power generated by each generator
@variable(model, z[g in G], Bin, start = 0)    # Binary variable indicating whether P_g[g] > 0
@variable(model, P_ij[l in L], start = Line_bias)      # Power flow on each line
@variable(model, θ[b in B], start = 0)         # Voltage angle at each bus
M = 1000.0

# Objective: Minimize the total generation cost
@objective(model, Min, sum(c_g[g] * P_g[g] for g in G))

# Nodal power balance constraints
@constraint(
    model,
    [i in B],
    sum(P_g[g] for g in G if g == i) - P_d[i] == sum(P_ij[l] for l in L if l[1] == i) - sum(P_ij[l] for l in L if l[2] == i)
)

# Conditional constraint: Enforce bounds only if P_g[g] > 0
for g in G
    # Constraint to ensure P_g[g] is within range if z[g] = 1
    @constraint(model, P_g_min[g] * z[g] <= P_g[g])
    @constraint(model, P_g[g] <= P_g_max[g] * z[g])
    
    # Ensure z[g] is 1 if P_g[g] is positive, using the Big-M method
    @constraint(model, P_g[g] <= M * z[g])
end

# Generation limits constraints
#@constraint(model, [g in G], P_g_min[g] <= P_g[g] <= P_g_max[g])

# Transmission line limits constraints
@constraint(model, [l in L], P_ij_min[l] <= P_ij[l] <= P_ij_max[l])

# DC power flow constraints
@constraint(model, [l in L], P_ij[l] == -b_ij[l] * (θ[l[1]] - θ[l[2]]) * 10e3)

# Set reference angle to zero (to avoid singularities)
@constraint(model, θ[1] == 0)

# Solve the model
optimize!(model)

# Check the solution status
if termination_status(model) == MOI.OPTIMAL
    println("Optimal solution found!")
    println("Objective Value: ", objective_value(model))
    println("Generation Output: ", value.(P_g))
    println("Line Flows: ", value.(P_ij))
    println("Voltage Angles: ", value.(θ))
else
    println("The model did not find an optimal solution.")
end
